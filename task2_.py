# -*- coding: utf-8 -*-
"""task2 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZMCaOK9qyQXpJIDMcZx7CgMcJ_7fZJg8
"""

#TASK 2 - RESTAURANT RECOMMENDATION BASED ON DIFFERENT CRITERIAS

#FIRST SAME EDA AND DATA PREPROCESSINGS
import pandas as pd
dataset_path = "/content/Dataset .csv"
df = pd.read_csv(dataset_path)
df.head(5)

df.columns

df.info()

df.describe()

df.isnull().sum()

df['Cuisines'].fillna(df['Cuisines'].mode()[0], inplace=True)
df.isnull().sum()

num_duplicates = df.duplicated().sum()
print(f"Number of duplicate rows: {num_duplicates}")
df = df.drop_duplicates()

numerical_columns = df.select_dtypes(include=['number']).columns.tolist()
categorical_columns = df.select_dtypes(include=['object']).columns.tolist()

print("Numerical Columns:\n", numerical_columns)
print("\nCategorical Columns:\n", categorical_columns)

unique_cuisines = df['Cuisines'].unique()
print("Unique Cuisines (First  Samples):\n", unique_cuisines[:10])

df_cuisine_encoded = df.copy()

df_cuisine_encoded = df_cuisine_encoded.join(df_cuisine_encoded['Cuisines'].str.get_dummies(sep=', '))
df_cuisine_encoded.drop(columns=['Cuisines'], inplace=True)
print("\nTransformed Dataset with Encoded Cuisines:\n", df_cuisine_encoded.head())

binary_columns = ['Has Table booking', 'Has Online delivery', 'Is delivering now', 'Switch to order menu']
df[binary_columns] = df[binary_columns].replace({'Yes': 1, 'No': 0})
print("Updated Binary Encoded Columns:\n", df[binary_columns].head())

rating_mapping = {
    'Not rated': 0,
    'Poor': 1,
    'Average': 2,
    'Good': 3,
    'Very Good': 4,
    'Excellent': 5
}

df['Rating Category'] = df['Rating text'].map(rating_mapping)
df.drop(columns=['Rating color', 'Rating text'], inplace=True)
print("Transformed Rating Category:\n", df[['Rating Category']].head())

df.head(2)

df_processed_sorted = df.sort_values(by='Aggregate rating', ascending=True)
print(df_processed_sorted.head())

df = df.join(df['Cuisines'].str.get_dummies(sep=', '))

df.drop(columns=['Cuisines'], inplace=True)
print("\nTransformed Dataset with Encoded Cuisines:\n", df.head())

#CUISINES ARE ENCODED

df.head(1)

from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MinMaxScaler


cuisine_columns = [col for col in df.columns if col not in [
    'Restaurant ID', 'Restaurant Name', 'Country Code', 'City', 'Address', 'Locality',
    'Locality Verbose', 'Longitude', 'Latitude', 'Currency', 'Rating color', 'Rating text'
]]

recommendation_features = cuisine_columns
df_filtered = df.copy()

scaler = MinMaxScaler()
df_filtered[['Average Cost for two', 'Aggregate rating', 'Votes']] = scaler.fit_transform(
    df_filtered[['Average Cost for two', 'Aggregate rating', 'Votes']]
)


#RECOMMENDATION BASED ON SIMILARITY

similarity_matrix = cosine_similarity(df_filtered[recommendation_features])
similarity_df = pd.DataFrame(similarity_matrix, index=df_filtered.index, columns=df_filtered.index)

def recommend_restaurants(restaurant_index, top_n=5):
    if restaurant_index not in similarity_df.index:
        print("Restaurant index not found.")
        return pd.DataFrame()
    similar_restaurants = similarity_df[restaurant_index].sort_values(ascending=False)[1:top_n+1]
    recommended_ids = similar_restaurants.index.tolist()

    return df.loc[recommended_ids, ['Restaurant Name', 'City', 'Address', 'Locality', 'Aggregate rating', 'Votes']]

restaurant_index = 0
recommended_restaurants = recommend_restaurants(restaurant_index, top_n=5)


print("\nRecommended Restaurants:\n", recommended_restaurants)

from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MinMaxScaler

feature_columns = [col for col in df.columns if col not in [
    'Restaurant ID', 'Restaurant Name', 'Country Code', 'City', 'Address', 'Locality',
    'Locality Verbose', 'Longitude', 'Latitude', 'Currency', 'Rating color', 'Rating text'
]]
df_filtered = df.copy()

scaler = MinMaxScaler()
df_filtered[['Average Cost for two', 'Aggregate rating', 'Votes']] = scaler.fit_transform(
    df_filtered[['Average Cost for two', 'Aggregate rating', 'Votes']]
)

similarity_matrix = cosine_similarity(df_filtered[feature_columns])
similarity_df = pd.DataFrame(similarity_matrix, index=df_filtered.index, columns=df_filtered.index)

def recommend_restaurants(restaurant_index, top_n=5):
    if restaurant_index not in similarity_df.index:
        print("Restaurant index not found.")
        return pd.DataFrame()
    similar_restaurants = similarity_df[restaurant_index].sort_values(ascending=False)[1:top_n+1]
    recommended_ids = similar_restaurants.index.tolist()

    return df.loc[recommended_ids, ['Restaurant Name', 'City', 'Address', 'Locality',
                                    'Price range', 'Average Cost for two', 'Aggregate rating',
                                    'Votes', 'Has Table booking', 'Has Online delivery',
                                    'Is delivering now', 'Switch to order menu']]

#NOW BASED ON MORE CRITERION

restaurant_index = 0  # Change this to the desired restaurant index
recommended_restaurants = recommend_restaurants(restaurant_index, top_n=5)

# Display recommendations
print("\nRecommended Restaurants:\n", recommended_restaurants)

#LETS DO KNNs
from sklearn.neighbors import NearestNeighbors
import numpy as np


collab_features = ['Aggregate rating', 'Votes', 'Price range', 'Average Cost for two']

df_collab = df_filtered[collab_features]


#USING KNNs
knn = NearestNeighbors(n_neighbors=5, metric='cosine')
knn.fit(df_collab)


def recommend_hybrid(restaurant_index, top_n=5):
    content_based_recommendations = recommend_restaurants(restaurant_index, top_n=top_n)
    distances, indices = knn.kneighbors([df_collab.iloc[restaurant_index]])
    collab_recommendations = df.loc[indices[0][1:top_n+1],
                                     ['Restaurant Name', 'City', 'Address', 'Aggregate rating', 'Votes']]
    final_recommendations = pd.concat([content_based_recommendations, collab_recommendations]).drop_duplicates()

    return final_recommendations.head(top_n)


restaurant_index = 0
recommended_restaurants = recommend_hybrid(restaurant_index, top_n=5)
print("\nHybrid Recommended Restaurants:\n", recommended_restaurants)

#RECOMMENDED RES BASED ON GEOLOCATION

from geopy.distance import geodesic
def filter_by_location(user_lat, user_lon, max_distance_km=10):
    def calculate_distance(row):
        return geodesic((user_lat, user_lon), (row['Latitude'], row['Longitude'])).km

    df_filtered['Distance'] = df_filtered.apply(calculate_distance, axis=1)

    return df_filtered[df_filtered['Distance'] <= max_distance_km]

user_lat, user_lon = 14.5655, 121.0275
nearby_restaurants = filter_by_location(user_lat, user_lon, max_distance_km=5)
print("\nNearby Restaurants Within 5 km:\n", nearby_restaurants[['Restaurant Name', 'City', 'Distance']].head())

from sklearn.metrics.pairwise import cosine_similarity
from sklearn.neighbors import NearestNeighbors
from sklearn.preprocessing import MinMaxScaler
from geopy.distance import geodesic
import pandas as pd
import numpy as np


scaler = MinMaxScaler()
df[['Average Cost for two', 'Aggregate rating', 'Votes']] = scaler.fit_transform(
    df[['Average Cost for two', 'Aggregate rating', 'Votes']]
)

#NOW WE ARE GOING FOR HYBRID APPROACH
#Content-Based Filtering
feature_columns = [col for col in df.columns if col not in [
    'Restaurant ID', 'Restaurant Name', 'Country Code', 'City', 'Address', 'Locality',
    'Locality Verbose', 'Longitude', 'Latitude', 'Currency', 'Rating color', 'Rating text'
]]

similarity_matrix = cosine_similarity(df[feature_columns])
similarity_df = pd.DataFrame(similarity_matrix, index=df.index, columns=df.index)

collab_features = ['Aggregate rating', 'Votes', 'Price range', 'Average Cost for two']
df_collab = df[collab_features]
knn = NearestNeighbors(n_neighbors=5, metric='cosine')
knn.fit(df_collab)

def filter_by_location(user_lat, user_lon, max_distance_km=10):
    """
    Filters restaurants within a given radius from the user's location.
    """
    def calculate_distance(row):
        return geodesic((user_lat, user_lon), (row['Latitude'], row['Longitude'])).km

    df_filtered = df.copy()
    df_filtered['Distance'] = df_filtered.apply(calculate_distance, axis=1)
    return df_filtered[df_filtered['Distance'] <= max_distance_km]

def recommend_restaurants(user_preferences, top_n=5):
    """
    Generates restaurant recommendations based on user preferences.

    Parameters:
        user_preferences (dict): Dictionary containing user preferences.
        top_n (int): Number of recommendations to return.

    Returns:
        DataFrame: Recommended restaurants matching user preferences.
    """

    df_filtered = df.copy()
    if 'Cuisine' in user_preferences:
        cuisine = user_preferences['Cuisine']
        if cuisine in df.columns:
            df_filtered = df_filtered[df_filtered[cuisine] == 1]

    if 'Price range' in user_preferences:
        df_filtered = df_filtered[df_filtered['Price range'] == user_preferences['Price range']]

    if 'Average Cost for two' in user_preferences:
        max_cost = user_preferences['Average Cost for two'] * 1.2
        min_cost = user_preferences['Average Cost for two'] * 0.8
        df_filtered = df_filtered[(df_filtered['Average Cost for two'] >= min_cost) &
                                  (df_filtered['Average Cost for two'] <= max_cost)]

    for col in ['Has Table booking', 'Has Online delivery', 'Is delivering now', 'Switch to order menu']:
        if col in user_preferences:
            df_filtered = df_filtered[df_filtered[col] == user_preferences[col]]

=    if 'Aggregate rating' in user_preferences:
        df_filtered = df_filtered[df_filtered['Aggregate rating'] >= user_preferences['Aggregate rating']]

    if 'Latitude' in user_preferences and 'Longitude' in user_preferences and 'Max Distance' in user_preferences:
        df_filtered = filter_by_location(user_preferences['Latitude'], user_preferences['Longitude'], user_preferences['Max Distance'])

    if df_filtered.empty:
        return pd.DataFrame()

    restaurant_index = df_filtered.index[0]
    similar_restaurants = similarity_df[restaurant_index].sort_values(ascending=False)[1:top_n+1]
    recommended_ids = similar_restaurants.index.tolist()

    distances, indices = knn.kneighbors([df_collab.iloc[restaurant_index]])
    collab_recommendations = df.iloc[indices[0][1:top_n+1]]
    recommendations = pd.concat([
        df_filtered[df_filtered.index.isin(recommended_ids)],
        collab_recommendations
    ]).drop_duplicates().head(top_n)

    return recommendations[['Restaurant Name', 'City', 'Address', 'Locality',
                            'Price range', 'Average Cost for two', 'Aggregate rating',
                            'Votes', 'Has Table booking', 'Has Online delivery',
                            'Is delivering now', 'Switch to order menu', 'Distance']]

# Example User Preferences
user_preferences = {
    'Cuisine': 'Italian',  # Preferred cuisine
    'Price range': 3,  # Preferred price range
    'Average Cost for two': 1000,  # Budget
    'Has Table booking': 1,  # Wants table booking
    'Has Online delivery': 1,  # Wants online delivery
    'Is delivering now': 1,  # Prefers active deliveries
    'Aggregate rating': 4.0,  # Minimum rating required
    'Latitude': 14.5655,  # User's latitude
    'Longitude': 121.0275,  # User's longitude
    'Max Distance': 5  # Max distance in KM
}
recommended_restaurants = recommend_restaurants(user_preferences, top_n=5)
print("\nFinal Optimized Recommended Restaurants:\n", recommended_restaurants)

from geopy.distance import geodesic
import pandas as pd


def recommend_nearby_restaurants(user_lat, user_lon, max_distance_km=5, top_n=10):
    """
    Recommends restaurants within a specified distance from the user's location.

    Parameters:
        user_lat (float): User's latitude.
        user_lon (float): User's longitude.
        max_distance_km (int): Maximum distance to consider for recommendations.
        top_n (int): Number of top recommendations.

    Returns:
        DataFrame: Nearby restaurant recommendations.
    """
    df_filtered = df.dropna(subset=['Latitude', 'Longitude']).copy()

    def calculate_distance(row):
        return geodesic((user_lat, user_lon), (row['Latitude'], row['Longitude'])).km

    df_filtered['Distance'] = df_filtered.apply(calculate_distance, axis=1)

    nearby_restaurants = df_filtered[df_filtered['Distance'] <= max_distance_km]
    return nearby_restaurants.sort_values(by='Distance').head(top_n)

user_lat = 14.5655  # User's latitude (Example: Manila, Philippines)
user_lon = 121.0275  # User's longitude
max_distance_km = 5  # Maximum distance (5 km)

recommended_restaurants = recommend_nearby_restaurants(user_lat, user_lon, max_distance_km)
print("\nNearby Restaurant Recommendations:\n", recommended_restaurants[['Restaurant Name', 'City', 'Address', 'Locality', 'Distance']])